// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol";
import {WAGACoffeeTokenCore} from "./WAGACoffeeTokenCore.sol";
import {WAGAProofOfReserve} from "./WAGAProofOfReserve.sol";
import {WAGAUpkeepLib} from "./libraries/WAGAUpkeepLib.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title WAGAInventoryManager2 - Gas Optimized
 * @dev Manages coffee inventory with Chainlink Functions for verification and Chainlink Automation for upkeep tasks
 * @dev Optimized for gas efficiency with batch data caching and reduced external calls
 */
contract WAGAInventoryManager2 is Ownable, AutomationCompatibleInterface {
    using WAGAUpkeepLib for uint8;

    /* -------------------------------------------------------------------------- */
    /*                                Custom errors                               */
    /* -------------------------------------------------------------------------- */
    error WAGAInventoryManager__InvalidPerformDataLength_performUpkeep();
    error WAGAInventoryManager__TooManyBatches_performUpkeep();
    error WAGAInventoryManager__UnknownUpkeepType_performUpkeep();
    error WAGAInventoryManager__InvalidThresholdValue_updateThresholds();
    error WAGAInventoryManager__EmptySourceCode_performVerificationCheck();
    error WAGAInventoryManager__ContractNotInitialized();
    error WAGAInventoryManager__BatchDoesNotExist_performVerificationCheck();
    error WAGAInventoryManager__BatchDoesNotExist_performExpiryCheck();
    error WAGAInventoryManager__BatchDoesNotExist_performLowInventoryCheck();
    error WAGAInventoryManager__BatchDoesNotExist_performLongStorageCheck();
    error WAGAInventoryManager__BatchDoesNotExist_performBatchAudit();
    error WAGAInventoryManager__InvalidBatchDataLength_checkUpkeep();

    /* -------------------------------------------------------------------------- */
    /*                               State Variables                              */
    /* -------------------------------------------------------------------------- */

    WAGACoffeeTokenCore public coffeeToken;
    WAGAProofOfReserve public proofOfReserve;

    // Gas optimization: Cache batch data to reduce external calls
    struct CachedBatchData {
        uint256 batchId;
        uint256 expiryDate;
        uint256 lastVerified;
        uint256 quantity;
        uint256 creationDate;
        bool isActive;
    }

    mapping(uint256 => uint256) private s_lastBatchAuditTime;

    // Source code storage for Chainlink Functions
    string private s_defaultSourceCode;
    mapping(uint256 => string) private s_batchSpecificSourceCode;

    // Gas optimization: Batch data cache with TTL
    mapping(uint256 => CachedBatchData) private s_batchDataCache;
    mapping(uint256 => uint256) private s_cacheTimestamp;
    uint256 private constant CACHE_TTL = 1 hours; // Cache for 1 hour

    uint256 public s_batchAuditInterval = 7 days;
    uint256 public s_expiryWarningThreshold = 60 days;
    uint256 public s_lowInventoryThreshold = 10;
    uint256 public s_longStorageThreshold = 180 days;
    uint256 public s_maxBatchesPerUpkeep = 50;

    uint256 public s_intervalSeconds;
    uint256 private s_lastTimeStamp;

    /* -------------------------------------------------------------------------- */
    /*                                   Events                                   */
    /* -------------------------------------------------------------------------- */

    event InventoryVerificationRequested(
        bytes32 indexed requestId,
        uint256 indexed batchId
    );
    event InventorySynced(uint256 indexed batchId, uint256 actualQuantity);
    event BatchMetadataMismatch(uint256 indexed batchId);
    event UpkeepPerformed(uint8 upkeepType, uint256[] batchIds);
    event LowInventoryWarning(uint256 indexed batchId, uint256 currentQuantity);
    event LongStorageWarning(uint256 indexed batchId, uint256 daysInStorage);
    event BatchDataCached(uint256 indexed batchId, uint256 timestamp);

    constructor(
        address coffeeTokenAddress,
        address proofOfReserveAddress
    ) Ownable(msg.sender) {
        coffeeToken = WAGACoffeeTokenCore(coffeeTokenAddress);
        proofOfReserve = WAGAProofOfReserve(proofOfReserveAddress);
        s_lastTimeStamp = block.timestamp;
    }

    /**
     * @notice Sets default source code for Chainlink Functions
     * @param sourceCode The JavaScript source code
     */
    function setDefaultSourceCode(
        string calldata sourceCode
    ) external onlyOwner {
        if (bytes(sourceCode).length == 0) {
            revert WAGAInventoryManager__EmptySourceCode_performVerificationCheck();
        }
        s_defaultSourceCode = sourceCode;
    }

    /**
     * @notice Sets batch-specific source code for Chainlink Functions
     * @param batchId The batch ID
     * @param sourceCode The JavaScript source code
     */
    function setBatchSourceCode(
        uint256 batchId,
        string calldata sourceCode
    ) external onlyOwner {
        if (bytes(sourceCode).length == 0) {
            revert WAGAInventoryManager__EmptySourceCode_performVerificationCheck();
        }
        s_batchSpecificSourceCode[batchId] = sourceCode;
    }

    /**
     * @notice Gets source code for a specific batch
     * @param batchId The batch ID
     * @return The source code to use for this batch
     */
    function getSourceCodeForBatch(
        uint256 batchId
    ) public view returns (string memory) {
        // Use batch-specific source code if available, otherwise use default
        if (bytes(s_batchSpecificSourceCode[batchId]).length > 0) {
            return s_batchSpecificSourceCode[batchId];
        }
        return s_defaultSourceCode;
    }

    /**
     * @dev Gas-optimized batch data caching
     * @param batchId The batch ID to cache
     */
    function _cacheBatchData(uint256 batchId) internal {
        // Check if cache is still valid
        if (block.timestamp - s_cacheTimestamp[batchId] < CACHE_TTL) {
            return;
        }

        // Fetch all batch data in one go to minimize external calls
        (
            uint256 productionDate,
            uint256 expiryDate,
            bool isVerified,
            uint256 quantity,
            uint256 pricePerUnit,
            ,
            ,
            ,
            uint256 lastVerifiedTimestamp
        ) = coffeeToken.getbatchInfo(batchId);

        // Get boolean flags from separate mappings - already retrieved above

        // Cache the data
        s_batchDataCache[batchId] = CachedBatchData({
            batchId: batchId,
            expiryDate: expiryDate,
            lastVerified: lastVerifiedTimestamp,
            quantity: quantity,
            creationDate: productionDate,
            isActive: coffeeToken.isBatchActive(batchId)
        });

        s_cacheTimestamp[batchId] = block.timestamp;
        emit BatchDataCached(batchId, block.timestamp);
    }

    /**
     * @dev Gas-optimized checkUpkeep with reduced external calls
     */
    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory performData)
    {
        // Check if enough time has passed since last upkeep
        if (block.timestamp - s_lastTimeStamp < s_intervalSeconds) {
            return (false, "");
        }

        // Get Active batches from the coffee token contract
        uint256[] memory activeBatches = coffeeToken.getActiveBatchIds();
        if (activeBatches.length == 0) {
            return (false, "");
        }

        // Gas optimization: Use dynamic arrays instead of fixed-size
        uint256[] memory expiryBatches = new uint256[](0);
        uint256[] memory verificationBatches = new uint256[](0);
        uint256[] memory lowInventoryBatches = new uint256[](0);
        uint256[] memory longStorageBatches = new uint256[](0);

        uint256 currentTime = block.timestamp;
        uint256 maxBatches = s_maxBatchesPerUpkeep;

        // Gas optimization: Process batches in chunks to avoid gas limit
        uint256 batchCount = activeBatches.length > maxBatches ? maxBatches : activeBatches.length;

        for (uint256 i = 0; i < batchCount; i++) {
            uint256 batchId = activeBatches[i];

            // Gas optimization: Use cached data when possible
            CachedBatchData memory cachedData = s_batchDataCache[batchId];
            
            // If cache is stale, we'll need to fetch fresh data
            bool useCache = (currentTime - s_cacheTimestamp[batchId]) < CACHE_TTL;
            
            uint256 expiryDate = useCache ? cachedData.expiryDate : coffeeToken.getBatchExpiryDate(batchId);
            uint256 lastVerified = useCache ? cachedData.lastVerified : coffeeToken.getBatchLastVerifiedTimestamp(batchId);
            uint256 quantity = useCache ? cachedData.quantity : coffeeToken.getBatchQuantity(batchId);
            uint256 creationDate = useCache ? cachedData.creationDate : coffeeToken.getBatchCreationDate(batchId);

            // Check for expired batches (highest priority)
            if (currentTime + s_expiryWarningThreshold >= expiryDate) {
                // Gas optimization: Use assembly for array expansion
                assembly {
                    let newLength := add(mload(expiryBatches), 1)
                    mstore(expiryBatches, newLength)
                    mstore(add(add(expiryBatches, 0x20), mul(sub(newLength, 1), 0x20)), batchId)
                }
                continue;
            }

            // Check for verification needed (second priority)
            if (currentTime - lastVerified >= s_batchAuditInterval) {
                assembly {
                    let newLength := add(mload(verificationBatches), 1)
                    mstore(verificationBatches, newLength)
                    mstore(add(add(verificationBatches, 0x20), mul(sub(newLength, 1), 0x20)), batchId)
                }
                continue;
            }

            // Check low inventory (third priority)
            if (quantity <= s_lowInventoryThreshold && quantity > 0) {
                assembly {
                    let newLength := add(mload(lowInventoryBatches), 1)
                    mstore(lowInventoryBatches, newLength)
                    mstore(add(add(lowInventoryBatches, 0x20), mul(sub(newLength, 1), 0x20)), batchId)
                }
                continue;
            }

            // Check long storage (fourth priority)
            uint256 daysInStorage = (currentTime - creationDate) / 1 days;
            if (daysInStorage >= s_longStorageThreshold) {
                assembly {
                    let newLength := add(mload(longStorageBatches), 1)
                    mstore(longStorageBatches, newLength)
                    mstore(add(add(longStorageBatches, 0x20), mul(sub(newLength, 1), 0x20)), batchId)
                }
                continue;
            }
        }

        // Return highest priority upkeep needed
        if (expiryBatches.length > 0) {
            performData = abi.encode(
                WAGAUpkeepLib.UPKEEP_EXPIRY_CHECK,
                expiryBatches
            );
            return (true, performData);
        }

        if (verificationBatches.length > 0) {
            performData = abi.encode(
                WAGAUpkeepLib.UPKEEP_VERIFICATION_CHECK,
                verificationBatches
            );
            return (true, performData);
        }

        if (lowInventoryBatches.length > 0) {
            performData = abi.encode(
                WAGAUpkeepLib.UPKEEP_LOW_INVENTORY_CHECK,
                lowInventoryBatches
            );
            return (true, performData);
        }

        if (longStorageBatches.length > 0) {
            performData = abi.encode(
                WAGAUpkeepLib.UPKEEP_LONG_STORAGE_CHECK,
                longStorageBatches
            );
            return (true, performData);
        }

        return (false, "");
    }

    /**
     * @dev Chainlink Automation perform function
     */
    function performUpkeep(bytes calldata performData) external override {
        // Update last timestamp
        s_lastTimeStamp = block.timestamp;

        if (performData.length < 32) {
            revert WAGAInventoryManager__InvalidPerformDataLength_performUpkeep();
        }

        (uint8 upkeepType, uint256[] memory batchIds) = abi.decode(
            performData,
            (uint8, uint256[])
        );

        if (batchIds.length > s_maxBatchesPerUpkeep) {
            revert WAGAInventoryManager__TooManyBatches_performUpkeep();
        }

        // Execute appropriate upkeep type
        if (upkeepType == WAGAUpkeepLib.UPKEEP_EXPIRY_CHECK) {
            performExpiryCheck(batchIds);
        } else if (upkeepType == WAGAUpkeepLib.UPKEEP_VERIFICATION_CHECK) {
            performVerificationCheck(batchIds);
        } else if (upkeepType == WAGAUpkeepLib.UPKEEP_LOW_INVENTORY_CHECK) {
            performLowInventoryCheck(batchIds);
        } else if (upkeepType == WAGAUpkeepLib.UPKEEP_LONG_STORAGE_CHECK) {
            performLongStorageCheck(batchIds);
        } else if (upkeepType == WAGAUpkeepLib.UPKEEP_INVENTORY_AUDIT) {
            performBatchAudit(batchIds);
        } else {
            revert WAGAInventoryManager__UnknownUpkeepType_performUpkeep();
        }

        emit UpkeepPerformed(upkeepType, batchIds);
    }

    /**
     * @dev Performs expiry checks on specific batches
     * @param batchIds Array of batch IDs to check
     */
    function performExpiryCheck(uint256[] memory batchIds) internal {
        for (uint256 i = 0; i < batchIds.length; i++) {
            uint256 batchId = batchIds[i];
            if (!coffeeToken.isBatchCreated(batchId)) {
                revert WAGAInventoryManager__BatchDoesNotExist_performExpiryCheck();
            }
            uint256 expiryDate = coffeeToken.getBatchExpiryDate(batchId);

            if (block.timestamp > expiryDate) {
                coffeeToken.markBatchExpired(batchId);
            }
        }
    }

    /**
     * @dev Performs verification checks on specific batches
     * @param batchIds Array of batch IDs to check
     */
    function performVerificationCheck(uint256[] memory batchIds) internal {
        for (uint256 i = 0; i < batchIds.length; i++) {
            uint256 batchId = batchIds[i];

            if (!coffeeToken.isBatchCreated(batchId)) {
                revert WAGAInventoryManager__BatchDoesNotExist_performVerificationCheck();
            }

            // Get source code for this batch
            string memory sourceCode = getSourceCodeForBatch(batchId);
            if (bytes(sourceCode).length == 0) {
                revert WAGAInventoryManager__EmptySourceCode_performVerificationCheck();
            }

            // Try to reset verification flags safely
            try coffeeToken.resetBatchVerificationFlags(batchId) {
                // Request inventory verification using stored source code
                proofOfReserve.requestInventoryVerification(
                    batchId,
                    sourceCode
                );

                // Update audit time
                s_lastBatchAuditTime[batchId] = block.timestamp;
            } catch {
                // If flag reset fails (e.g., due to pending redemptions), skip this batch
                continue;
            }
        }
    }

    /**
     * @dev Performs low inventory checks on specific batches
     * @param batchIds Array of batch IDs to check
     */
    function performLowInventoryCheck(uint256[] memory batchIds) internal {
        for (uint256 i = 0; i < batchIds.length; i++) {
            uint256 batchId = batchIds[i];
            if (!coffeeToken.isBatchCreated(batchId)) {
                revert WAGAInventoryManager__BatchDoesNotExist_performLowInventoryCheck();
            }
            uint256 currentQuantity = coffeeToken.getBatchQuantity(batchId);

            if (
                currentQuantity > 0 &&
                currentQuantity <= s_lowInventoryThreshold
            ) {
                emit LowInventoryWarning(batchId, currentQuantity);
            }
        }
    }

    /**
     * @dev Performs long storage checks on specific batches
     * @param batchIds Array of batch IDs to check
     */
    function performLongStorageCheck(uint256[] memory batchIds) internal {
        for (uint256 i = 0; i < batchIds.length; i++) {
            uint256 batchId = batchIds[i];
            if (!coffeeToken.isBatchCreated(batchId)) {
                revert WAGAInventoryManager__BatchDoesNotExist_performLongStorageCheck();
            }
            uint256 productionDate = coffeeToken.getBatchCreationDate(batchId);

            if (block.timestamp - productionDate > s_longStorageThreshold) {
                uint256 daysInStorage = (block.timestamp - productionDate) /
                    1 days;
                emit LongStorageWarning(batchId, daysInStorage);
            }
        }
    }

    /**
     * @dev Performs inventory audits on specific batches
     * @param batchIds Array of batch IDs to audit
     */
    function performBatchAudit(uint256[] memory batchIds) internal {
        for (uint256 i = 0; i < batchIds.length; i++) {
            uint256 batchId = batchIds[i];
            if (!coffeeToken.isBatchCreated(batchId)) {
                revert WAGAInventoryManager__BatchDoesNotExist_performBatchAudit();
            }
            s_lastBatchAuditTime[batchId] = block.timestamp;
        }
    }

    /**
     * @dev Updates various threshold values for upkeep conditions
     */
    function updateBatchAuditInterval(
        uint256 _batchAuditInterval
    ) external onlyOwner {
        s_batchAuditInterval = _batchAuditInterval;
    }

    function updateExpiryWarningThreshold(
        uint256 _expiryWarningThreshold
    ) external onlyOwner {
        s_expiryWarningThreshold = _expiryWarningThreshold;
    }

    function updateLowInventoryThreshold(
        uint256 _lowInventoryThreshold
    ) external onlyOwner {
        s_lowInventoryThreshold = _lowInventoryThreshold;
    }

    function updateLongStorageThreshold(
        uint256 _longStorageThreshold
    ) external onlyOwner {
        s_longStorageThreshold = _longStorageThreshold;
    }

    function updateMaxBatchesPerUpkeep(
        uint256 _maxBatchesPerUpkeep
    ) external onlyOwner {
        if (_maxBatchesPerUpkeep == 0 || _maxBatchesPerUpkeep > 100) {
            revert WAGAInventoryManager__InvalidThresholdValue_updateThresholds();
        }
        s_maxBatchesPerUpkeep = _maxBatchesPerUpkeep;
    }

    /**
     * @dev Returns the last audit time for a specific batch
     */
    function getLastBatchAuditTime(
        uint256 batchId
    ) external view returns (uint256) {
        return s_lastBatchAuditTime[batchId];
    }

    function setBatchAuditInterval(uint256 intervalSeconds) external onlyOwner {
        s_intervalSeconds = intervalSeconds;
    }

    /**
     * @dev Clear batch data cache (emergency function)
     */
    function clearBatchDataCache(uint256 batchId) external onlyOwner {
        delete s_batchDataCache[batchId];
        delete s_cacheTimestamp[batchId];
    }

    /**
     * @dev Get cached batch data for debugging
     */
    function getCachedBatchData(uint256 batchId) external view returns (
        uint256 expiryDate,
        uint256 lastVerified,
        uint256 quantity,
        uint256 creationDate,
        bool isActive,
        uint256 cacheTimestamp
    ) {
        CachedBatchData memory data = s_batchDataCache[batchId];
        return (
            data.expiryDate,
            data.lastVerified,
            data.quantity,
            data.creationDate,
            data.isActive,
            s_cacheTimestamp[batchId]
        );
    }
}
