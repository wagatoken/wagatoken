// SPDX-License-Identifier: MIT
pragma solidity ^0.8.18;

import {ERC1155} from "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import {ERC1155Supply} from "@openzeppelin/contracts/token/ERC1155/extensions/ERC1155Supply.sol";
import "./WAGAConfigManager.sol";
import "./WAGAViewFunctions.sol";
import "./WAGABatchManager.sol";
import "./WAGAZKManager.sol";
import "./Interfaces/IPrivacyLayer.sol";
import "./Interfaces/IZKVerifier.sol";

/**
 * @title WAGACoffeeTokenCore
 * @dev Core ERC1155 token that delegates to modular managers for batch and ZK operations
 */
contract WAGACoffeeTokenCore is ERC1155Supply, WAGAConfigManager, WAGAViewFunctions {
    
    /* -------------------------------------------------------------------------- */
    /*                                   Errors                                   */
    /* -------------------------------------------------------------------------- */
    
    error WAGACoffeeTokenCore__BatchAlreadyExists_createBatch();
    error WAGACoffeeTokenCore__InvalidQuantity_createBatch();
    error WAGACoffeeTokenCore__InvalidPrice_createBatch();
    error WAGACoffeeTokenCore__AccessControlUnauthorizedAccount_createBatch();
    error WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
    error WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchURI();
    error WAGACoffeeTokenCore__BatchDoesNotExist_transferBatch();
    error WAGACoffeeTokenCore__InsufficientBalance_transferBatch();
    error WAGACoffeeTokenCore__BatchDoesNotExist_mintBatch();
    error WAGACoffeeTokenCore__BatchQuantityExceeded_mintBatch();
    error WAGACoffeeTokenCore__BatchDoesNotExist_burnForRedemption();
    error WAGACoffeeTokenCore__BatchQuantityExceeded_burnForRedemption();
    error WAGACoffeeTokenCore__InsufficientBatchQuantity_burnForRedemption();

    /* -------------------------------------------------------------------------- */
    /*                                   Events                                   */
    /* -------------------------------------------------------------------------- */

    event BatchCreated(
        uint256 indexed batchId,
        address indexed creator,
        uint256 quantity,
        uint256 pricePerUnit,
        string metadataURI
    );

    event BatchStatusUpdated(
        uint256 indexed batchId,
        bool isActive
    );

    event BatchTransferred(
        uint256 indexed batchId,
        address indexed from,
        address indexed to,
        uint256 amount
    );

    /* -------------------------------------------------------------------------- */
    /*                               State Variables                              */
    /* -------------------------------------------------------------------------- */

    // Modular manager contracts
    WAGABatchManager public batchManager;
    WAGAZKManager public zkManager;

    // Basic token state
    mapping(uint256 => string) public s_batchMetadata; // Token metadata URIs
    mapping(uint256 => bool) public batchCreated; // Track created batches
    mapping(uint256 => bool) public batchActive; // Track active batches (needed for compatibility)
    uint256 public batchCounter; // Total batches created

    /* -------------------------------------------------------------------------- */
    /*                                Constructor                                 */
    /* -------------------------------------------------------------------------- */

    constructor(
        string memory baseURI
    ) ERC1155(baseURI) WAGAConfigManager() WAGAViewFunctions() {
        // Grant roles to deployer
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    /**
     * @dev Set manager contracts (admin only)
     */
    function setManagerContracts(
        address _batchManager,
        address _zkManager
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        batchManager = WAGABatchManager(_batchManager);
        zkManager = WAGAZKManager(_zkManager);
    }

    /* -------------------------------------------------------------------------- */
    /*                              Core Functions                               */
    /* -------------------------------------------------------------------------- */

     /**
     * @dev Create a new coffee batch - delegates to BatchManager for full ZK functionality
     */
    function createBatch(
        uint256 productionDate,
        uint256 expiryDate,
        uint256 quantity,
        uint256 pricePerUnit,
        string calldata packagingInfo,
        string calldata metadataHash
    ) external returns (uint256) {
        // Only admins and processors can create batches
        if (!hasRole(ADMIN_ROLE, msg.sender) && !hasRole(PROCESSOR_ROLE, msg.sender)) {
            revert WAGACoffeeTokenCore__AccessControlUnauthorizedAccount_createBatch();
        }
        if (quantity == 0) {
            revert WAGACoffeeTokenCore__InvalidQuantity_createBatch();
        }
        if (pricePerUnit == 0) {
            revert WAGACoffeeTokenCore__InvalidPrice_createBatch();
        }

        // Generate batch ID 
        uint256 batchId = ++batchCounter;

        // Mark batch as created
        batchCreated[batchId] = true;
        s_batchMetadata[batchId] = metadataHash;

        // Delegate full batch creation to BatchManager (modular approach)
        batchManager.createBatchInfo(
            batchId,
            productionDate,
            expiryDate,
            quantity,
            pricePerUnit,
            "Origin TBD", // origin (can be updated later)
            packagingInfo,
            IPrivacyLayer.PrivacyLevel.MODERATE // Default privacy level
        );

        emit BatchCreated(batchId, msg.sender, quantity, pricePerUnit, metadataHash);
        return batchId;
    }

    /**
     * @dev Simplified createBatch for testing - calls the main function
     */
    function createBatchSimple(
        uint256 quantity,
        uint256 pricePerUnit,
        string memory metadataURI
    ) external returns (uint256) {
        return createBatch(
            block.timestamp, // productionDate
            block.timestamp + 365 days, // expiryDate
            quantity,
            pricePerUnit,
            "Standard", // packagingInfo
            metadataURI // metadataHash
        );
    }

    /**
     * @dev Mint tokens for verified batch - delegate to batch manager validation
     */
    function mintBatch(
        address to,
        uint256 batchId,
        uint256 amount
    ) external onlyRole(MINTER_ROLE) {
        if (!batchCreated[batchId]) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_mintBatch();
        }
        
        BatchInfo memory batch = s_batchInfo[batchId];
        if (batch.mintedQuantity + amount > batch.quantity) {
            revert WAGACoffeeTokenCore__BatchQuantityExceeded_mintBatch();
        }

        // Update minted quantity
        s_batchInfo[batchId].mintedQuantity += amount;

        // Mint tokens
        _mint(to, batchId, amount, "");
    }

    /**
     * @dev Burn tokens for redemption
     */
    function burnForRedemption(
        address from,
        uint256 batchId,
        uint256 amount
    ) external {
        if (!batchCreated[batchId]) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_burnForRedemption();
        }
        
        // Check if caller has permission (redemption contract or token holder)
        if (msg.sender != from && !isApprovedForAll(from, msg.sender) && !hasRole(REDEMPTION_ROLE, msg.sender)) {
            revert WAGACoffeeTokenCore__AccessControlUnauthorizedAccount_createBatch();
        }

        uint256 balance = balanceOf(from, batchId);
        if (balance < amount) {
            revert WAGACoffeeTokenCore__InsufficientBatchQuantity_burnForRedemption();
        }

        // Burn tokens
        _burn(from, batchId, amount);
    }

    /**
     * @dev Verify batch metadata - delegates to ZK manager
     */
    function verifyBatchMetadata(
        uint256 batchId,
        string calldata metadataHash,
        bytes calldata zkProof
    ) external returns (bool) {
        if (!batchCreated[batchId]) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }

        // Delegate ZK verification to ZK manager
        bool isValid = zkManager.verifyZKProof(batchId, zkProof, IZKVerifier.ProofType.QUALITY);
        
        if (isValid) {
            s_batchInfo[batchId].metadataHash = metadataHash;
            s_batchInfo[batchId].isMetadataVerified = true;
            s_batchInfo[batchId].lastVerifiedTimestamp = block.timestamp;
        }

        return isValid;
    }

    /**
     * @dev Update inventory quantity
     */
    function updateInventory(
        uint256 batchId,
        uint256 newQuantity
    ) external onlyRole(INVENTORY_MANAGER_ROLE) {
        if (!batchCreated[batchId]) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        if (newQuantity == 0) {
            revert WAGACoffeeTokenCore__InvalidQuantity_createBatch();
        }

        s_batchInfo[batchId].quantity = newQuantity;
    }

    /**
     * @dev Update batch metadata URI
     */
    function updateBatchURI(
        uint256 batchId,
        string calldata newURI
    ) external onlyRole(PROCESSOR_ROLE) {
        if (!batchCreated[batchId]) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchURI();
        }

        s_batchMetadata[batchId] = newURI;
        s_batchInfo[batchId].metadataHash = newURI;
    }

    /**
     * @dev Transfer batch tokens between addresses
     */
    function transferBatch(
        uint256 batchId,
        address from,
        address to,
        uint256 amount
    ) external {
        if (!batchCreated[batchId]) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_transferBatch();
        }
        if (balanceOf(from, batchId) < amount) {
            revert WAGACoffeeTokenCore__InsufficientBalance_transferBatch();
        }

        _safeTransferFrom(from, to, batchId, amount, "");
        emit BatchTransferred(batchId, from, to, amount);
    }

    /* -------------------------------------------------------------------------- */
    /*                               View Functions                               */
    /* -------------------------------------------------------------------------- */

    /**
     * @dev Get total number of batches created
     */
    function getTotalBatches() external view returns (uint256) {
        return batchCounter;
    }

    /**
     * @dev Set manager contract addresses (admin only)
     */
    function setManagerAddresses(
        address _batchManager,
        address _zkManager
    ) external onlyRole(DEFAULT_ADMIN_ROLE) {
        batchManager = _batchManager;
        zkManager = _zkManager;
    }

    /**
     * @dev Check if caller is a manager contract
     */
    function isManagerContract(address caller) external view returns (bool) {
        return caller == batchManager || caller == zkManager;
    }

    /**
     * @dev Get batch packaging info (needed for ProofOfReserve)
     */
    function getBatchPackagingInfo(uint256 batchId) external view returns (string memory) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        return s_batchInfo[batchId].packagingInfo;
    }

    /**
     * @dev Get batch metadata hash (needed for ProofOfReserve)
     */
    function getBatchMetadataHash(uint256 batchId) external view returns (string memory) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        return s_batchInfo[batchId].metadataHash;
    }

    /**
     * @dev Check if batch metadata is verified (needed for ProofOfReserve)
     */
    function isBatchMetadataVerified(uint256 batchId) external view returns (bool) {
        if (!isBatchCreated(batchId)) {
            return false;
        }
        return s_batchInfo[batchId].isMetadataVerified;
    }

    /**
     * @dev Mint tokens for a specific batch (only MINTER_ROLE)
     * @param to Recipient address
     * @param batchId Batch identifier
     * @param amount Amount to mint
     */
    function mintBatch(
        address to,
        uint256 batchId,
        uint256 amount
    ) external onlyRole(MINTER_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_mintBatch();
        }
        
        // Check that we don't exceed batch quantity
        if (s_batchInfo[batchId].mintedQuantity + amount > s_batchInfo[batchId].quantity) {
            revert WAGACoffeeTokenCore__BatchQuantityExceeded_mintBatch();
        }
        
        // Update minted quantity
        s_batchInfo[batchId].mintedQuantity += amount;
        
        // Mint the tokens
        _mint(to, batchId, amount, "");
        
        emit BatchTransferred(batchId, address(0), to, amount);
    }

    /**
     * @dev Burn tokens for redemption (only REDEMPTION_ROLE)
     * @param from Address to burn from
     * @param batchId Batch identifier
     * @param amount Amount to burn
     */
    function burnForRedemption(
        address from,
        uint256 batchId,
        uint256 amount
    ) external onlyRole(REDEMPTION_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_burnForRedemption();
        }
        
        // Validate burning doesn't exceed minted quantity
        if (amount > s_batchInfo[batchId].mintedQuantity) {
            revert WAGACoffeeTokenCore__BatchQuantityExceeded_burnForRedemption();
        }
        
        // Validate amount is greater than 0
        if (amount == 0) {
            revert WAGACoffeeTokenCore__InsufficientBatchQuantity_burnForRedemption();
        }
        
        // Update minted quantity (decrease)
        s_batchInfo[batchId].mintedQuantity -= amount;
        
        // Burn tokens
        _burn(from, batchId, amount);
        
        emit BatchTransferred(batchId, from, address(0), amount);
    }

    /* -------------------------------------------------------------------------- */
    /*                         BATCH MANAGEMENT FUNCTIONS                        */
    /* -------------------------------------------------------------------------- */

    /**
     * @dev Update batch inventory quantity (only admins)
     * @param batchId Batch identifier
     * @param newQuantity New quantity for the batch
     */
    function updateInventory(uint256 batchId, uint256 newQuantity) external onlyRole(ADMIN_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        if (newQuantity == 0) {
            revert WAGACoffeeTokenCore__InvalidQuantity_createBatch();
        }
        s_batchInfo[batchId].quantity = newQuantity;
    }

    /**
     * @dev Verify batch metadata (only admins)
     * @param batchId Batch identifier
     * @param verifiedPrice Verified price
     * @param verifiedPackaging Verified packaging
     * @param verifiedMetadataHash Verified metadata hash
     */
    function verifyBatchMetadata(
        uint256 batchId,
        uint256 verifiedPrice,
        string calldata verifiedPackaging,
        string calldata verifiedMetadataHash
    ) external onlyRole(ADMIN_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }

        BatchInfo storage info = s_batchInfo[batchId];
        
        if (info.pricePerUnit != verifiedPrice ||
            keccak256(bytes(info.packagingInfo)) != keccak256(bytes(verifiedPackaging)) ||
            keccak256(bytes(info.metadataHash)) != keccak256(bytes(verifiedMetadataHash))) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus(); // Reusing error for metadata mismatch
        }

        info.isMetadataVerified = true;
        info.lastVerifiedTimestamp = block.timestamp;
    }

    /**
     * @dev Update batch last verified timestamp (only admins)
     * @param batchId Batch identifier
     * @param timestamp New timestamp
     */
    function updateBatchLastVerifiedTimestamp(uint256 batchId, uint256 timestamp) external onlyRole(ADMIN_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        s_batchInfo[batchId].lastVerifiedTimestamp = timestamp;
    }

    /**
     * @dev Mark batch as expired (only inventory manager)
     * @param batchId Batch identifier
     */
    function markBatchExpired(uint256 batchId) external onlyRole(INVENTORY_MANAGER_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        batchActive[batchId] = false;
        s_isActiveBatch[batchId] = false;
    }

    /**
     * @dev Reset batch verification flags (only inventory manager)
     * @param batchId Batch identifier
     */
    function resetBatchVerificationFlags(uint256 batchId) external onlyRole(INVENTORY_MANAGER_ROLE) {
        if (!isBatchCreated(batchId)) {
            revert WAGACoffeeTokenCore__BatchDoesNotExist_updateBatchStatus();
        }
        s_batchInfo[batchId].isVerified = false;
        s_batchInfo[batchId].isMetadataVerified = false;
    }

    /* -------------------------------------------------------------------------- */
    /*                              Override Functions                            */
    /* -------------------------------------------------------------------------- */

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155, AccessControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns the URI for token type `id`.
     */
    function uri(uint256 tokenId)
        public
        view
        override
        returns (string memory)
    {
        return s_batchMetadata[tokenId];
    }
}
